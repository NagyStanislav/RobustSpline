% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hello.R
\name{ts_interpolate}
\alias{ts_interpolate}
\title{Interpolating functional data using thin-plate splines}
\usage{
ts_interpolate(Xtobs, r, p.out = 101, I = c(0, 1), solve.method = c("C", "R"))
}
\arguments{
\item{Xtobs}{A list of length \code{n}, each element of \code{Xtobs} is a 
list with two elements corresponding to the \code{i}-th function: 
(a) \code{X} A numerical vector of length \code{p} of observed values of 
the \code{i}-th function, where \code{p} is the number of observations for
this function. (b) \code{tobs} Domain locations for the observed points of 
the \code{i}-th function corresponding to \code{X}. Matrix of size 
\code{p}-times-\code{d}, one row per domain point. Here, \code{d} is the 
dimension of the domain of \code{X}.}

\item{r}{Order of the thin-plate spline, positive integer.}

\item{p.out}{Number of equi-distant points in which the densely observed
thin-plate spline interpolation of each function should be evaluated. In
dimension \code{d}, a total of \code{p.out^d} points are evaluated in the 
hyper-cube \code{[I[1],I[2]]^d}, and at these points, 
each function is evaluated.}

\item{I}{Two numbers \code{I[1]<I[2]} determining the box 
\code{[I[1],I[2]]^d} where all the interpolated functions are evaluated.}

\item{solve.method}{Indicator of which solver of systems of linear equations
to use for the inversion of the matrices in the interpolation procedure. 
Possible options are \code{"C"} for the solver from \code{Armadillo} library
in \code{C++}, or \code{R} for the function \link[base]{solve} from \code{R}.}
}
\value{
A list of values:
\itemize{
 \item{"X"}{ A matrix of size \code{n}-times-\code{p.out^d} of the function
 values of the densely evaluated interpolated data. One function per row.}
 \item{"tobs"}{ A matrix of size \code{p.out^d}-times-\code{d} with all the
 coodinates of the points where the function values are evaluated.
 }
 }
}
\description{
Given a discretely (and possibly) irregularly observed sample of functional
data, this function performs thin-plate spline interpolation of each 
functional datum. As an output, a matrix or function values of densely
observed interpolated functional data in a common grid of the domain 
is obtained.
}
\examples{

# Construct the irregularly observed functional data
Xtobs = list()

# Number of observations and dimension of the domain
n = 10
d = 1

# Generating functions as random noise
for(i in 1:n){
 p = 10 + rpois(1, 5) # Number of observed points for the i-th function
 tobs = matrix(runif(p*d),ncol=d) # Points in the domain
 X = rnorm(p,sd=0.05) # Observed function values
 Xtobs[[i]] = list(X=X, tobs=tobs)
}
 
# Thin-plate spline interpolation of order r=4
intr = ts_interpolate(Xtobs, r = 4)
 
# Visalization of the i-th function
i = 1
if(d==1){
 plot(Xtobs[[i]]$X~Xtobs[[i]]$tobs[,1])  
 lines(intr$X[i,]~intr$tobs[,1])
}
if(d==2){
 rgl::plot3d(Xtobs[[i]]$tobs[,1], Xtobs[[i]]$tobs[,2], Xtobs[[i]]$X)
 rgl::points3d(intr$tobs[,1], intr$tobs[,2], intr$X[i,],col="red",add=TRUE)
}
}
