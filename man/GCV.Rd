% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hello.R
\name{GCV}
\alias{GCV}
\title{Cross-Validation for the IRLS procedure}
\usage{
GCV(
  lambda,
  Z,
  Y,
  H,
  type,
  alpha = 1/2,
  sc = 1,
  vrs = "C",
  custfun = NULL,
  resids.in = rep(1, length(Y)),
  toler = 1e-07,
  imax = 1000
)
}
\arguments{
\item{lambda}{A candidate parameter value; non-negative real number.}

\item{Z}{Data matrix of dimension \code{n}-times-\code{p}, where \code{n} is
the number of observations, \code{p} is the dimension.}

\item{Y}{Vector of responses of length \code{n}.}

\item{H}{Penalty matrix of size \code{p}-times-\code{p} that
is used inside the quadratic term for penalizing estimated parameters.}

\item{type}{The type of the loss function used in the minimization problem.
Accepted are \code{type="absolute"} for the absolute loss \code{rho(t)=|t|/2};
\code{type="quantile"} for the (asymmetric) quantile loss 
\code{rho(t)=t(alpha-I[t<0])} (\code{absolute} loss with \code{alpha=1/2});
\code{type="square"} for the square loss \code{rho(t)=t^2}; 
\code{type="Huber"} for the Huber loss \code{rho(t)=t^2/2} if 
\code{|t|<tuning} and \code{rho(t)=tuning*(|t|-tuning/2)} otherwise; and 
\code{type="logistic"} for the logistic loss 
\code{rho(t)=2*t + 4*log(1+exp(-t))-4*log(2)}.}

\item{alpha}{The order of the quantile if \code{type="quantile"}. By default
taken to be \code{alpha=1/2}, which gives the absolute loss 
(\code{type="absolute"}).}

\item{sc}{Scale parameter to be used in the IRLS. By default \code{sc=1}, 
that is no scaling is performed.}

\item{vrs}{Version of the algorhitm to be used in function \link{IRLS}; 
either \code{vrs="C"} for the \code{C++} version, or \code{vrs="R"} for the 
\code{R} version. Both should give (nearly) identical results, see 
\link{IRLS}.}

\item{custfun}{A custom function combining the residuals \code{resids} and
the hat values \code{hats}. The result of the function must be numeric, 
see \link{GCV_crit}.}

\item{resids.in}{Initialization of the vector of residuals used to launch 
the IRLS algorithms. Optional.}

\item{toler}{A small positive constant specifying the tolerance level for 
terminating the algorithm. The prcedure stops if the maximum absolute 
distance between the residuals in the previous iteration and the new 
residuals drops below \code{toler}.}

\item{imax}{Maximum number of allowed iterations of IRLS.}
}
\value{
A named numerical vector of values. The length of the vector depends
on the input. The vector contains the values:
\itemize{
 \item{"AIC"}{ Akaike's information criterion given by 
 \code{mean(resids^2)+log(n)*mean(hats)}, where \code{n} is the length of
 both \code{resids} and \code{hats}.}
 \item{"GCV"}{ Leave-one-out cross-validation criterion given by
 \code{mean((resids^2)/((1-hats)^2))}.}
 \item{"GCV(tr)"}{ Modified leave-one-out cross-validation criterion 
 given by \code{mean((resids^2)/((1-mean(hats))^2))}.}
 \item{"BIC"}{ Bayes information criterion given by 
 \code{mean(resids^2)+2*mean(hats)}.}
 \item{"rGCV"}{ A robust version of \code{GCV} where mean is replaced
 by a robust M-estimator of scale of \code{resids/(1-hats)}, see 
 \link[robustbase]{scaleTau2} for details.}
 \item{"rGCV(tr)"}{ Modified version of a \code{rGCV} given by 
 a robust M-estimator of scale of \code{resids/(1-mean(hats))}.}
 \item{"custom"}{ The custom criterion given by function \code{custfun}. 
 Works only if \code{custfun} is part of the input.}
}
}
\description{
Provides the cross-validation indices from \link{GCV_crit} in
conjunction with the \link{IRLS} function directly as an argument of the
parameter \code{lambda}.
}
\details{
Function \code{custfun} has two arguments 
corresponding to \code{resids} and \code{hats}. The output of the function 
must be numeric.
}
\examples{
n = 50      # sample size
p = 10      # dimension of predictors
Z = matrix(rnorm(n*p),ncol=p) # design matrix
Y = Z[,1]   # response vector
lambda = 1  # tuning parameter for penalization
H = diag(p) # penalty matrix
type = "absolute" # absolute loss

# Run with the IRLS procedure
res = IRLS(Z, Y, lambda, H, type)
with(res,GCV_crit(resids,hat_values))
with(res,GCV_crit(resids,hat_values,custfun = function(r,h) sum(r^2)))
    
GCV(lambda,Z,Y,H,type,custfun = function(r,h) sum(r^2))
}
