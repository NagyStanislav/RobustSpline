% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hello.R
\name{generate}
\alias{generate}
\title{Generate a dataset for scalar-on-function linear regression}
\usage{
generate(
  alpha0,
  beta0,
  n,
  d,
  p,
  bfX,
  bcX,
  sd.noiseEps,
  obs_only = FALSE,
  p1 = 101,
  sd.noiseX = 0
)
}
\arguments{
\item{alpha0}{A real value of the intercept parameter.}

\item{beta0}{A function parameter. A real function whose arguments are
\code{d}-dimensional vectors.}

\item{n}{Sample size.}

\item{d}{Dimension of the domain of \code{X} and \code{beta0}.}

\item{p}{The size of the discretization grid where the functions \code{X} are
observed. The observation points are sampled randomly from the full grid of
all \code{p1^d} points in the domain.}

\item{bfX}{A list of basis functions for \code{X}. Each element of \code{bfX}
contains the list of values of a basis function when evaluated in a complete
grid of observations, that is \code{p1^d} real values.}

\item{bcX}{A matrix of basis coefficients that are combined with the basis
functions from \code{bfX} to get the regressor functions \code{X}. The matrix
must be of dimensions \code{n}-times-\code{K}, where \code{n} is the sample
size, and \code{K} is the length of the list \code{bfX}.}

\item{sd.noiseEps}{Standard deviation for the noise component \code{eps}. 
Noise is generated to be centered Gaussian, independent of \code{X}.}

\item{obs_only}{Indictar of whether to generate the response \code{Y}
the functions \code{X} and \code{beta0} should be used in the complete 
grid of size \code{p1^d} (\code{obs_only=FALSE}), or only in the grid 
of size \code{p} where \code{X} is observed (\code{obs_only=FALSE}). By
default set to \code{FALSE}.}

\item{p1}{The complete size of the discretization grid where the 
(practically unobservable) complete version of the function \code{X} is 
known. \code{p1} corresponds to the complete grid in dimension 1; if 
\code{d>1}, the same grid is replicated also in the other dimensions and the
resulting size of the domain is \code{p1^d}. By default, 
\code{p1=101}.}

\item{sd.noiseX}{Standard deviation of an additional noise component that is
added to the regressors \code{X}. The final regressor functions are obtained
by taking a linear combination of basis functions from \code{bfX} weighted
by the coefficients from \code{bcX}, and then adding indepenent centered 
normal noise to each of the \code{p1^d} of its values with standard
deviation \code{sd.noiseX}. By default, \code{sd.noiseX = 0}.}
}
\value{
A list composed of several elements. Some of these elements are
assumed to be observed; some are given for post-estimation diagnostic 
purposes. The elements that are assumed to be observed are:
\itemize{
 \item{"tgrid"}{ A complete grid of observation points in one dimension, 
 replicated in each dimension if \code{d>1}. An equidistant grid of 
 \code{p1} points in the interval [0,1].}
 \item{"X"}{ Matrix of observed values of \code{X} of size 
 \code{n}-times-\code{p}, one row per observation, columns corresponding to the 
 positions in the rows of \code{tobs}.}
 \item{"Y"}{ A vector of observed responses, size \code{n}.}
 \item{"tobs"}{ Domain locations for the observed points of \code{X}. Matrix
 of size \code{p}-times-\code{d}, one row per domain point.}
}
Additional data for diagnostic purposes that is not assumed to be observed:
\itemize{
 \item{"Xfull"}{ A \code{d+1}-dimensional array of completely observed 
 values of functions \code{X} of size 
 \code{n}-times-\code{p1}-...-times-\code{p1}. The first dimension is for 
 observations, additional ones for dimensions of the
 domain, i.e. \code{Xfull[2,4,5]} stands for the function value of function 2
 at the domain points \code{(tgrid[4],tgrid[5])} for \code{d=2}.}
 \item{"betafull"}{ A \code{d}-dimensional array of the values of the 
 regression function \code{beta0} of size \code{p1}-times-...-times-\code{p1}.
 Interpretation of values as for the functions of \code{Xfull}.}
 \item{"tfull"}{ A flattened matrix of the full grid of all observation 
 points. A matrix of size \code{p1^d}-times-\code{d}, each row 
 corersponding to the domain vector of a single point where \code{Xfull} and
 \code{betafull} are evaluated.}
 \item{"betafull0"}{ A vector of all evaluated values of the function 
 \code{beta0} in the complete grid of \code{p1^d} observation points. A 
 numerical vector of length \code{p1^d}, each value corresponding to a 
 row of \code{tfull}. Idential to a flattened version of \code{betafull}.}
 \item{"truemean"}{ A vector of length \code{n} of the true conditional mean 
 values of Y given the i-th regressor from \code{X}, without the intercept
 \code{alpha0}.}
 \item{"eps"}{ Vector of erros used in the regression. Naturally, 
 \code{Y = truemean + eps + alpha0}.}
 \item{"d"}{ Dimension of the domain of regressors.}
}
}
\description{
Generates the data according to the model 
\code{Y = alpha0 + int beta0(t)*X(t) dt + epsilon}, where \code{X} are the 
regressor functions, \code{alpha0} is a real parameter, \code{beta0} is a 
functional parameter, and \code{epsilon} are independent error terms. 
The domain of \code{X} and \code{beta0} can be one-dimensional, or also
higher-dimensional. The functional data \code{X} are assumed to be observed
only in an incomplete grid of \code{p} points in its domain.
}
\examples{
d = 1       # dimension of domain
n = 50      # sample size
p = 10      # number of observed points in domain
p1 = 101 # size of the complete grid
alpha0 = 3  # intercept
beta0 = function(t) t^2 # regression coefficient function
sd.noiseEps = 0.1 # noise standard deviation
tgrid = seq(0,1,length=p1) # full grid of observation points

# Generating the basis functions for X
basis_fun = function(t,k) return(sin(2*pi*k*t)+t^k)

K = 5 # number of basis functions used in the expansion
bfX = list()
for(k in 1:K) bfX[[k]] = basis_fun(tgrid,k)
bcX = matrix(rnorm(n*K,mean=3,sd=5),ncol=K)  # basis coefficients

gen = generate(alpha0, beta0, n, d, p, bfX, bcX, sd.noiseEps)

# plot the first regressor function
plot(gen$Xfull[1,]~tgrid,type="l",main="Predictor X",lwd=2)

# plot the true mean values against the responses
plot(gen$truemean+alpha0, gen$Y)
abline(a=0,b=1)

# Check that the response is modelled as alpha0 + truemean + eps
all.equal(gen$Y,alpha0 + gen$truemean + gen$eps)

# Check that the truemean is an approximation to the integral of X and beta0
all.equal(apply(gen$Xfull,1,function(x) mean(x*gen$betafull)),gen$truemean)

# Check that betafull0 is flattened version of betafull
all.equal(c(gen$betafull), gen$betafull0)
}
