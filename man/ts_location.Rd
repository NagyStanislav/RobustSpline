% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hello.R
\name{ts_location}
\alias{ts_location}
\title{Robust thin-plate splines location estmation for functional data}
\usage{
ts_location(
  Y,
  tobs,
  r,
  type,
  jcv = "all",
  vrs = "C",
  method = "IRLS",
  plotCV = FALSE,
  lambda_grid = NULL,
  lambda_length = 51,
  custfun = NULL
)
}
\arguments{
\item{Y}{Matrix of observed values of functional data \code{Y} of size 
\code{p}-times-\code{n}, one column per observation, rows corresponding to 
the positions in the rows of \code{tobs}. Functions observed on different 
grids can be provided by including missing values \code{NA} in the matrix.}

\item{tobs}{Domain locations for the observed points of \code{Y}. Matrix
of size \code{p}-times-\code{d}, one row per domain point.}

\item{r}{Order of the thin-plate spline, positive integer.}

\item{type}{The type of the loss function used in the minimization problem.
Accepted are \code{type="absolute"} for the absolute loss \code{rho(t)=|t|}; 
\code{type="square"} for the square loss \code{rho(t)=t^2}; 
\code{type="Huber"} for the Huber loss \code{rho(t)=t^2/2} if 
\code{|t|<tuning} and \code{rho(t)=tuning*(|t|-tuning/2)} otherwise; and 
\code{type="logistic"} for the logistic loss 
\code{rho(t)=2*t + 4*log(1+exp(-t))-4*log(2)}.}

\item{jcv}{A numerical indicator of the cross-validation method used to 
select the tuning parameter \code{lambda}. The criteria are always 
based on the residuals (\code{resids}) and hat values (\code{hats}) in
the fitted models. Possible values are:
\itemize{
 \item{"all"}{ All the criteria below are considered.}
 \item{"AIC"}{ Akaike's information criterion given by 
 \code{mean(resids^2)+log(n)*mean(hats)}, where \code{n} is the length of
 both \code{resids} and \code{hats}.}
 \item{"GCV"}{ Leave-one-out cross-validation criterion given by
 \code{mean((resids^2)/((1-hats)^2))}.}
 \item{"GCV(tr)"}{ Modified leave-one-out cross-validation criterion 
 given by \code{mean((resids^2)/((1-mean(hats))^2))}.}
 \item{"BIC"}{ Bayes information criterion given by 
 \code{mean(resids^2)+2*mean(hats)}.}
 \item{"rGCV"}{ A robust version of \code{GCV} where mean is replaced
 by a robust M-estimator of scale of \code{resids/(1-hats)}, see 
 \link[robustbase]{scaleTau2} for details.}
 \item{"rGCV(tr)"}{ Modified version of a \code{rGCV} given by 
 a robust M-estimator of scale of \code{resids/(1-mean(hats))}.}
 \item{"custom"}{ The custom criterion given by function \code{custfun}. 
 Works only if \code{custfun} is part of the input.}
 }}

\item{vrs}{Version of the algorhitm to be used in function \link{ridge}; 
either \code{vrs="C"} for the \code{C++} version, or \code{vrs="R"} for the 
\code{R} version. Both should give (nearly) identical results, see 
\link{IRLS}.}

\item{method}{A method for estimating the fit. Possible options are 
\code{"IRLS"} for the IRLS algorithm, or \code{"ridge"} for ridge regression.
Ridge is applicable only if \code{type="square"}; this method is much faster,
but provides only a non-robust fit.}

\item{plotCV}{Indicator of whether a plot of the evaluated cross-validation 
criteria as a function of \code{lambda} should be given.}

\item{lambda_grid}{An optional grid for select \code{lambda} from. By default
this is set to be an exponential of a grid of \code{lambda_length} 
equidistant values in the interval from -28 to -1.}

\item{lambda_length}{Number of elements in the grid of values \code{lambda}. 
By default chosen to be 51.}

\item{custfun}{A custom function combining the residuals \code{resids} and
the hat values \code{hats}. The result of the function must be numeric, see 
\link{GCV_crit}.}
}
\value{
The output differs depending whether \code{jcv="all"} or 
not. If a specific cross-validation method is selected (that is, 
\code{jcv} is not \code{"all"}), a list is returned:
 \itemize{
 \item{"lambda"}{ The selected tuning parameter \code{lambda} that minimizes
 the chosen cross-validation criterion.}
 \item{"fitted"}{ A vector of fitted values using the tuning 
 parameter \code{lambda}. The length of this vector equals \code{m}, the 
 number of non-missing values in the matrix \code{Y}. If \code{Y} does not
 contain missing values, the length of this vector is \code{n*p}.}
 \item{"theta_hat"}{ A numerical matrix of size \code{p}-times-\code{1} of 
 estimated regression coefficients from \link{IRLS}.}
 \item{"beta_hat"}{ The final location estimate \code{beta} 
 evaluated at the \code{p} points from \code{tobs}, where \code{Y} was
 observed. A numerical vector of length \code{p}.}
 \item{"hat_values"}{ Diagonal terms of the (possibly penalized and weighted)
 hat matrix of the form \code{Z*solve(t(Z)*W*Z+n*lambda*H)*t(Z)*W}, 
 where \code{W} is the diagonal weight matrix in the final iteration 
 of \link{IRLS}. A numerical vector of length \code{m}.}
 \item{"weights"}{ The vector of weights given to the observations in the 
 final iteration of \link{IRLS}. A numerical vector of length \code{m}.}
 \item{"converged"}{ Indicator whether the \link{IRLS} procedure succefully 
 converged. Takes value 1 if IRLS converged, 0 otherwise.}
}
In case when \code{jcv="all"}, all these values are given for each 
cross-validation method considered. For \code{lambda} and \code{converged} 
provides a list of length 6 or 7 (depending on whether \code{custfun} is 
specified); for \code{fitted}, \code{beta_hat},
\code{hat_values}, and \code{weights} it gives a matrix with 6 or 7 
columns, each corresponding to one cross-validation method.
}
\description{
Provides a (potentially robust) thin-plates spline location estimator for 
discretely observed functional data. The functional data do not need to be 
observed on a common grid (that is, \code{NA} values in the matrix \code{Y}
below are allowed). The tuning parameter \code{lambda} is selected using a 
specified cross-validation criterion.
}
\examples{
d = 1                              # dimension of domain
m = 50                             # number of observation points
tobs = matrix(runif(m*d), ncol=d)  # location of obsevation points
n = 20                             # sample size
truemeanf = function(x)            # true location function 
  cos(4*pi*x[1])
truemean = apply(tobs,1,truemeanf) # discretized values of the true location
Y = replicate(n, truemean + rnorm(m)) # a matrix of functional data, size m*n

# introduce NAs
obsprob = 0.2                      # probability of a point being observed
B = matrix(rbinom(n*m,1,obsprob),ncol=n)
for(i in 1:m) for(j in 1:n) if(B[i,j]==0) Y[i,j] = NA

res = ts_location(Y, tobs=tobs, r=2, type="square", plotCV=TRUE)
}
\references{
Ioannis Kalogridis and Stanislav Nagy. (2025). Robust multidimensional 
location estimation from discretely sampled functional data. 
\emph{Under review}.
}
