% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hello.R
\name{transform_theta_location}
\alias{transform_theta_location}
\title{Transform the vector of estimated coefficients for location estimation}
\usage{
transform_theta_location(theta, tspr)
}
\arguments{
\item{theta}{Output vector of raw results of length \code{p} from function
\link{IRLS} or \link{ridge}.}

\item{tspr}{Output of \link{ts_preprocess_location}.}
}
\value{
A list of estimated parameters:
\itemize{
 \item{"xi_hat"}{ Estimate of \code{xi}, the part of the parameters that
 correspond to matrix \code{Omega} when transformed by \code{Q}. A vector
 of length \code{(p-M)}.}
 \item{"delta_hat"}{ Estimate of \code{delta}, the part of the parameters that
 correspond to matrix \code{Phi}. A vector of length \code{M}, the number of
 monomials used for the construction of the thin-plate spline.}
 \item{"gamma_hat"}{ Estimate of \code{gamma}, the part of the parameters that
 correspond to matrix \code{Omega}. It holds true that 
 \code{gamma_hat = Q*xi_hat}. A vector of length \code{p}.}
 \item{"beta_hat"}{ Estimate of the location parameter \code{mu} 
 evaluated at the \code{p} points from \code{tobs}, where \code{Y} was
 observed.}
}
}
\description{
Splits the vector of raw estimated coefficients (output of functions 
\link{IRLS} or \link{ridge}) after performing \link{ts_preprocess_locationi} 
into parts interpretable in the setup of thin-plate spline location 
estimation.
}
\examples{
d = 1  # dimension of the domain
m = 50 # number of observation times per function
tobs = matrix(runif(m*d), ncol=d) # matrix of observation times
n = 20 # sample size
truemeanf = function(x) 10+15*x[1]^2 # true mean function
truemean = apply(tobs,1,truemeanf) # discretized values of the true mean
Y = replicate(n, truemean + rnorm(m)) # matrix of discrete functiona data, size p*n
tsp = ts_preprocess_location(Y, tobs, 2) # preprocessing matrices 

lambda0 = 1e-5 # regularization parameter
res_IRLS = IRLS(Z = tsp$Z, Y = tsp$Y, lambda = lambda0, H = tsp$H, type = "square")
res_ridge = ridge(Z = tsp$Z, Y = tsp$Y, lambda = lambda0, H = tsp$H)
# resulting estimates of the parameters theta, using IRLS and ridge

# testing that ridge and IRLS (square) give the same results
all.equal(res_IRLS$theta_hat, res_ridge$theta_hat)

res = res_ridge
resf = transform_theta_location(res$theta_hat, tsp)

plot(rep(tobs,n), c(Y), cex=.2, pch=16)
points(tobs, truemean, pch=16, col="orange")
points(tobs, resf$beta_hat, col=2, pch=16)
}
