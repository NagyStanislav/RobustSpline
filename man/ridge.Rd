% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hello.R
\name{ridge}
\alias{ridge}
\title{Fast Ridge Regression with given penalty matrix}
\usage{
ridge(Z, Y, lambda, H, w = NULL, vrs = "C", toler_solve = 1e-35)
}
\arguments{
\item{Z}{Data matrix of dimension \code{n}-times-\code{p}, where \code{n} is
the number of observations, \code{p} is the dimension.}

\item{Y}{Vector of responses of length \code{n}.}

\item{lambda}{Tuning parameter, a non-negative real number.}

\item{H}{Penalty matrix of size \code{p}-times-\code{p} that
is used inside the quadratic term for penalizing estimated parameters.}

\item{w}{Vector of length \code{n} of weights attached to the elements of 
\code{Y}. If \code{w=NULL} (default), a constant vector with values 
\code{1/n} is used.}

\item{vrs}{Version of the algorhitm to be used. The program is prepared in
two versions: i) \code{vrs="C"} calls the \code{C++} version of the 
algorithm, programmed within the \code{RCppArmadillo} framework for
manipulating matrices. This is typically the fastest version. 
ii) \code{vrs="R"} calls the \code{R} version. The two versions may 
give slightly different results due to the differences in evaluating inverse
matrices. With \code{vrs="C"} one uses the function \code{solve} directly
from \code{Armadillo} library in \code{C++}; with \code{vrs="R"} the 
standard function \code{solve} from \code{R} package \code{base} is used 
with the option \code{tol = toler_solve}.}

\item{toler_solve}{A small positive constant to be passed to function
\link[base]{solve} as argument \code{tol}. Used to handle numerically 
singular matrices whose inverses need to be approximated. By default set to
1e-35.}
}
\value{
A list composed of:
\itemize{
 \item{"theta_hat"}{ A numerical matrix of size \code{p}-times-\code{1} of 
 estimated regression coefficients.}
 \item{"resids"}{ A numerical vecotor of length \code{n} containing the final
 set of residuals in the fit of \code{Y} on \code{Z}.}
 \item{"hat_values"}{ Diagonal terms of the (penalized) hat matrix of
 the form \code{Z*solve(t(Z)*Z + n*lambda*H)*t(Z)}.}
 \item{"fitted"}{ Fitted values in the model. A vector of length \code{n} 
 correponding to the fits of \code{Y}.}
}
}
\description{
A (weighted) ridge regression estimator with a specified penalty matrix
in a linear regression model. The solution corresponds to the 
result of function \link{IRLS} with \code{type="square"}.
}
\details{
Especially for extremely small values of \code{lambda}, numerically
singular matrices must be inverted in the procedure. This may cause numerical
instabilites, and is the main cause for differences in results when using
\code{vrs="C"} and \code{vrs="R"}. This function is equivalent with 
\link{IRLS} when used with the square loss \code{type="square"}, but faster
and more stable as it does not perform the iterative algorithm. Instead, it 
computes the estimator directly.
}
\examples{
n = 50      # sample size
p = 10      # dimension of predictors
Z = matrix(rnorm(n*p),ncol=p) # design matrix
Y = Z[,1]   # response vector
lambda = 1  # tuning parameter for penalization
H = diag(p) # penalty matrix

res_C = ridge(Z, Y, lambda, H, vrs="C")
res_R = ridge(Z, Y, lambda, H, vrs="R")
# Check the maximum absolute difference between the results
max(abs(res_C$theta_hat-res_R$theta_hat))
# Visualise the difference between the results
plot(res_C$theta_hat ~ res_R$theta_hat)

# Compare the output with function IRLS
res_IRLS = IRLS(Z, Y, lambda, H, type="square")
max(abs(res_C$theta_hat-res_IRLS$theta_hat))
}
\seealso{
\link{IRLS} for a robust version of this
function.
}
